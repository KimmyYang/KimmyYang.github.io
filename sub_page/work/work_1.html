<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.0.6 (451290)"/><meta name="author" content="Kimmy"/><meta name="created" content="2016-10-03 08:17:15 +0000"/><meta name="updated" content="2016-10-04 03:32:28 +0000"/><title>[Android] NetworkFactory建立過程</title></head><body><div><span style="font-size: 21px;"><b>版權聲明: 未經同意請勿轉載, 欲轉載請來信告知</b></span></div><div><b><span style="font-size: 21px;"><br/></span></b></div><div><b><span style="font-size: 24px;">前言:</span></b></div><div><span style="font-size: 16px;">每個提供網路服務的component 都需要create NetworkFactory (create會是NetworkFactory的子類, ex.在telephoney create會是TelephonyNetworkFactory)</span></div><div><span style="font-size: 16px;">NetworkFactory中, needNetworkFor 會實作在子類別中</span></div><div><span style="font-size: 16px;">以6.0來說, telephony的會實作在DctController.java裡面</span></div><div><span style="font-size: 16px;">但以7.0來說, telephony會新增一個class/檔案叫TelephonyNetworkFactory.java, 並實作在裡面</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">以下是6.0例子</span></div><div><img src="%5BAndroid%5D%20NetworkFactory%E5%BB%BA%E7%AB%8B%E9%81%8E%E7%A8%8B.resources/BD9C49D2-1B84-4DED-8512-FD813282CA53.png" height="554" width="840"/></div><div><br/></div><div><span style="font-size: 16px;"><br/></span></div><div><b><span style="font-size: 24px;">NetworkFactory init 過程</span></b></div><div><span style="font-size: 16px;">6.0 : 在DctController 建構子中...去new TelephonyNetworkFactory</span></div><div><span style="font-size: 16px;">7.0 : 在PhoneFactory中被創建, 並會把DcTracker帶進去 (由於DcTracker是Phone去create的, 而Phone是在PhoneFactory被create的, 所以由此這邊把DcTracker帶進去)</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">在create TelephonyNetworkFactory需要注意的...</span></div><ol><li><span style="font-size: 16px;">set Capability (比照6.0, 7.0用封裝的方式...統一在TelephonyNetworkFactory做整理, 6.0是帶值方式做設定)</span></li><li><span style="font-size: 16px;">mPhoneSwitcher (新功能...之後研究)</span></li><li><span style="font-size: 16px;">register (向ConnectivityService做註冊)</span></li></ol><div><span style="font-size: 16px;">7.0:</span></div><div><span style="font-size: 16px;"><img src="%5BAndroid%5D%20NetworkFactory%E5%BB%BA%E7%AB%8B%E9%81%8E%E7%A8%8B.resources/FD11E230-CC14-4921-A20D-0C9C021DD5FF.png" height="634" width="1052"/></span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">NetworkFactory -- register() : 向ConnectivityService做註冊</span></div><div><span style="font-size: 16px;">首先透過 ConnectivityManager 發起registerNetworkFactory</span></div><div><span style="font-size: 16px;">透過aidl 呼叫到 ConnectivitiyService</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">ConnectivityService.java</span></div><div><span style="font-size: 16px;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">nfi 是在 ConnectivityService&nbsp;&nbsp;registerNetworkFactory中 new 出來的</span></span></div><div><span style="font-size: 16px;">NetworkFactory在ConnectivityService是以NetworkFactoryInfo存在</span></div><div><span style="font-size: 16px;">而messenger是從NetworkFactory傳過來的, 是在NetworkFactory的一個private&nbsp;&nbsp;Messenger 成員變數</span></div><div><img src="%5BAndroid%5D%20NetworkFactory%E5%BB%BA%E7%AB%8B%E9%81%8E%E7%A8%8B.resources/F87003BB-8970-4B82-A659-93EF8B77E662.png" height="133" width="1001"/></div><div><br/></div><div><img src="%5BAndroid%5D%20NetworkFactory%E5%BB%BA%E7%AB%8B%E9%81%8E%E7%A8%8B.resources/44912346-B895-4DDB-BB28-1735FB105E86.png" height="116" width="806"/></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;">剛剛在registerNetworkFactory有new了一個AsyncChannel , 現在透過他來做單向connect&nbsp;&nbsp;</span></div><div><span style="font-size: 16px;">(AsyncChannel像是介於 NetworkFactory &lt;-&gt; ConnectvitiyService , NetworkAgent &lt;-&gt; ConnectivityService 之間的連接通道,</span></div><div><span style="font-size: 16px;">透過傳送過來的 srcHandler 和 mDstHandler 去決定把msg傳去傳回哪邊)</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">從handleRegisterNetworkFactory 傳過去的 srcHandler -&gt; mTrackerHandler (他是在ConnectivityService宣告的Handler, 所以src會傳回到ConnectivityService)</span></div><div><span style="font-size: 16px;">dstMessenger就是剛剛從NetworkFactory傳過來的Messenger囉</span></div><div><br/></div><div>connected的部分會做成員參數的assign</div><div>//source</div><div>mSrcContext = srcContext;</div><div>mSrcHandler = srcHandler;</div><div>mSrcMessenger = new Messenger(mSrcHandler);</div><div>//dest</div><div>mDstMessenger = dstMessenger;</div><div><img src="%5BAndroid%5D%20NetworkFactory%E5%BB%BA%E7%AB%8B%E9%81%8E%E7%A8%8B.resources/D6438217-13C2-44BE-86BB-E85977CA3C37.png" height="474" width="959"/></div><div><br/></div><div><span style="font-size: 16px;">接著, 透過replyHalfConnected 傳送<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">CMD_CHANNEL_HALF_CONNECTED</span> 到Source (ConnectivityService) &nbsp;&nbsp;發送</span></div><div><span style="font-size: 16px;">ConnectivityService收到CMD_CHANNEL_HALF_CONNECTED後, 便完成單向connected</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">ConnectivityService收到之後, 會執行handleAsyncChannelHalfConnect,</span></div><div><span style="font-size: 16px;">透過ac傳送<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">CMD_REQUEST_NETWORK</span></span></div><div><span style="font-size: 16px;">第二個參數 : 因為初始化, 所以從mNetworkForRequestId 拿到的nai會是 null , 所以會帶0</span></div><div><span style="font-size: 16px;">第三個參數 : 初始score</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">ConnectivityService.java</span></div><div><img src="%5BAndroid%5D%20NetworkFactory%E5%BB%BA%E7%AB%8B%E9%81%8E%E7%A8%8B.resources/F8E83485-5B30-469C-BF2F-612D6A735A89.png" height="337" width="988"/></div><div><br/></div><div><span style="font-size: 16px;">ac.sendMessage , 最後會透過ac的dstMessager (其實就是NetworkFactory)送出CMD_REQUEST_NETWORK, 最後在NetworkFactory收到</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">因為初始化過程, 所以n == null , 會去new一個NetworkRequestInfo, 並存在mNetworkRequests中</span></div><div><span style="font-size: 16px;"><br/></span></div><div><b><span style="font-size: 24px;">評分機制 : <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">evalRequest(n)</span></span></b></div><div><br/></div><div><span style="font-size: 16px;">NetworkFactory.java</span></div><div><img src="%5BAndroid%5D%20NetworkFactory%E5%BB%BA%E7%AB%8B%E9%81%8E%E7%A8%8B.resources/836E8093-8BDC-4DB8-9362-6CFC3E57BB04.png" height="326" width="904"/></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;">初始過程, n.requestd == false (如果變true, 表示當前的網路被needNetworkFor過, 表示有連上data)</span></div><div><span style="font-size: 16px;">再來會比score, n.score(初始化 = 0) 指當前request score的分數 , &nbsp;&nbsp;mScore表示目前自己的分數 (telephony data = 50)</span></div><div><span style="font-size: 16px;">如果發現requested == false 沒有被建立, 並且當前request 分數小於 自己的分數, 便執行 needNetworkFor, 並把requested設成true</span></div><div><br/></div><div><span style="font-size: 16px;">如果request的分數比自己大, 則把自己的網路release掉, 並且把requested設成false</span></div><div><br/></div><div><span style="font-size: 16px;">NetworkFactory.java</span></div><div><img src="%5BAndroid%5D%20NetworkFactory%E5%BB%BA%E7%AB%8B%E9%81%8E%E7%A8%8B.resources/0AC56A59-58CE-47D4-950A-82726E87138D.png" height="387" width="1050"/></div><div><br/></div><div><br/></div><div><b><span style="font-size: 24px;">分數補充:&nbsp;&nbsp;</span></b></div><div><span style="font-size: 16px;">每個數據連線都會有自己的NetworkFactory, 每個數據也會更新自己的score(updateNetworkScore)或是狀態(updateNetworkInfo),&nbsp;&nbsp;</span></div><div><span style="font-size: 16px;">當更新自己的score時, 也會透過ConnectivityService的mNetworkFactoryInfos (在</span><span style="font-size: 16px;">handleRegisterNetworkFactory存)去for loop所有NetworkFactory,</span></div><div><span style="font-size: 16px;">並透過送<span style="margin:0px;padding:0px;border:none;color:black;background-color:inherit;">CMD_REQUEST_NETWORK</span>&nbsp;&nbsp;到 NetworkFactory一併去更新他們的狀態 (前面提到</span><span style="font-size: 16px;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">evalRequest</span></span> <span style="font-size: 16px;">的方式</span><span style="font-size: 16px;">)</span></div></body></html>